generator client {
  provider = "prisma-client"
  output   = "../generated/prisma/"
}

datasource db {
  provider = "postgresql"
}

enum AuthProvider {
  discord
  steam
}

enum FrequencyType {
  SR
  LR
}

model User {
  id                Int                @id @default(autoincrement())
  username          String?
  email             String?
  avatarUrl         String?
  isAdmin           Boolean            @default(false)
  createdAt         DateTime           @default(now())
  accounts          AuthAccount[]
  orbats            Orbat[]            @relation("OrbatCreator")
  signups           Signup[]
  orbatTemplates    OrbatTemplate[]
  userTrainings     UserTraining[]
  trainingRequests  TrainingRequest[]
  handledRequests   TrainingRequest[]  @relation("TrainingRequestHandledBy")
  attendances       Attendance[]
  attendanceLogs    AttendanceLog[]
  attendanceSessions AttendanceSession[]
  legacyMappings    LegacyAttendanceData[]
  createdMessages   Message[]          @relation("MessageCreator")
  messageRecipients MessageRecipient[]
  // Rank system
  userRank          UserRank?
  rankHistory       RankHistory[]
  promotionProposals PromotionProposal[]
}

enum MessageType {
  orbat
  training
  rankup
  general
  alert
}

enum AudienceType {
  user      // Direct to user
  rank      // To all users with specific rank
  all       // Broadcast to all users
  admin     // Admin-only alerts
}

enum DeliveryChannel {
  web
  discord   // Future: Discord DM or channel delivery
}

model Message {
  id           Int       @id @default(autoincrement())
  title        String
  body         String    @db.Text
  type         MessageType @default(general)
  actionUrl    String?
  createdBy    User?     @relation("MessageCreator", fields: [createdById], references: [id], onDelete: SetNull)
  createdById  Int?
  createdAt    DateTime  @default(now())
  recipients   MessageRecipient[]

  @@index([type])
  @@index([createdAt])
}

model MessageRecipient {
  id            Int       @id @default(autoincrement())
  message       Message   @relation(fields: [messageId], references: [id], onDelete: Cascade)
  messageId     Int
  user          User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  userId        Int
  audienceType  AudienceType
  audienceValue String?   // e.g., rankId for rank-based, null for all/user/admin
  isRead        Boolean   @default(false)
  readAt        DateTime?
  deliveredAt   DateTime  @default(now())
  channel       DeliveryChannel @default(web)
  metadata      Json?     // Flexible storage for future delivery-specific data

  @@unique([messageId, userId])
  @@index([userId, isRead])
  @@index([messageId])
  @@index([audienceType])
}

model AuthAccount {
  id             Int          @id @default(autoincrement())
  user           User         @relation(fields: [userId], references: [id], onDelete: Cascade)
  userId         Int
  provider       AuthProvider // Using enum here for clarity
  providerUserId String

  @@unique([provider, providerUserId])
}

model Orbat {
  id               Int       @id @default(autoincrement())
  name             String
  description      String?
  eventDate        DateTime?
  startTime        String?
  endTime          String?
  createdBy        User      @relation("OrbatCreator", fields: [createdById], references: [id])
  createdById      Int
  createdAt        DateTime  @default(now())
  isMainOp         Boolean   @default(false)
  slots            Slot[]
  frequencies      OrbatRadioFrequency[]
  attendances      Attendance[]
  tempFrequencies  Json?     @default("[]") // Store temporary frequencies as JSON array
  // BLUFOR faction
  bluforCountry    String?
  bluforRelationship String?
  // OPFOR faction
  opforCountry     String?
  opforRelationship String?
  // Independent faction
  indepCountry     String?
  indepRelationship String?
  // Extra Intel
  iedThreat        String?   // IED/Trap/Mine Threat
  civilianRelationship String? // Civilian Relationship
  rulesOfEngagement String?  // Rules of Engagement
  airspace         String?   // Airspace
  inGameTimezone   String?   // In Game Timezone
  operationDay     String?   // Operation Day
}

model Slot {
  id         Int       @id @default(autoincrement())
  orbat      Orbat     @relation(fields: [orbatId], references: [id], onDelete: Cascade)
  orbatId    Int
  name       String
  orderIndex Int
  subslots   Subslot[]
}

model Subslot {
  id         Int       @id @default(autoincrement())
  slot       Slot      @relation(fields: [slotId], references: [id], onDelete: Cascade)
  slotId     Int
  name       String
  orderIndex Int
  maxSignups Int       @default(1)
  signups    Signup[]
}

model RadioFrequency {
  id           Int       @id @default(autoincrement())
  frequency    String    @unique // e.g., "70.0"
  type         FrequencyType // SR or LR
  isAdditional Boolean   @default(false) // True for ASR (Additional Short Range), etc
  channel      String?   // e.g., "SR Channel 1", "LR Channel 1"
  callsign     String?   // Optional callsign
  createdAt    DateTime  @default(now())
  orbats       OrbatRadioFrequency[]
}

model OrbatRadioFrequency {
  id              Int      @id @default(autoincrement())
  orbat           Orbat    @relation(fields: [orbatId], references: [id], onDelete: Cascade)
  orbatId         Int
  radioFrequency  RadioFrequency @relation(fields: [radioFrequencyId], references: [id], onDelete: Cascade)
  radioFrequencyId Int

  @@unique([orbatId, radioFrequencyId])
  @@index([orbatId])
}

model Signup {
  id        Int      @id @default(autoincrement())
  subslot   Subslot  @relation(fields: [subslotId], references: [id], onDelete: Cascade)
  subslotId Int
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  userId    Int
  createdAt DateTime @default(now())
  attendance Attendance?

  @@unique([subslotId, userId])
  @@index([userId])  // Indexing for fast lookup
}

enum AttendanceStatus {
  present      // Full attendance
  absent       // Manually marked absent
  late         // Arrived after first hour
  gone_early   // Left before last hour
  partial      // Both late and gone_early with >=60 mins total missed
  no_show      // Never checked in
}

model Attendance {
  id                    Int              @id @default(autoincrement())
  signup                Signup?          @relation(fields: [signupId], references: [id], onDelete: Cascade)
  signupId              Int?             @unique
  orbat                 Orbat            @relation(fields: [orbatId], references: [id], onDelete: Cascade)
  orbatId               Int
  user                  User             @relation(fields: [userId], references: [id], onDelete: Cascade)
  userId                Int
  status                AttendanceStatus @default(absent)
  
  // Time tracking - individual sessions for multiple check-in/check-outs
  sessions              AttendanceSession[]
  minutesLate           Int              @default(0) // Minutes late in first hour (from first session)
  minutesGoneEarly      Int              @default(0) // Minutes early in last hour (from last session)
  totalMinutesMissed    Int              @default(0) // minutesLate + minutesGoneEarly
  totalMinutesPresent   Int              @default(0) // Sum of all session durations
  
  notes                 String?          // Optional admin notes
  createdAt             DateTime         @default(now())
  updatedAt             DateTime         @updatedAt
  logs                  AttendanceLog[]

  @@index([orbatId])
  @@index([userId])
  @@index([createdAt])
}

model AttendanceSession {
  id              Int       @id @default(autoincrement())
  attendance      Attendance? @relation(fields: [attendanceId], references: [id], onDelete: Cascade)
  attendanceId    Int?
  user            User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  userId          Int
  checkedInAt     DateTime
  checkedOutAt    DateTime?
  durationMinutes Int?      // Calculated when checked out: (checkedOutAt - checkedInAt) in minutes
  sessionDate     DateTime  // Date of the session (for querying by date)
  timestamp       DateTime  @default(now())

  @@index([userId])
  @@index([sessionDate])
  @@index([attendanceId])
  @@index([timestamp])
}

model AttendanceLog {
  id              Int      @id @default(autoincrement())
  attendance      Attendance @relation(fields: [attendanceId], references: [id], onDelete: Cascade)
  attendanceId    Int
  action          String   // "created", "status_changed", "notes_updated", "time_updated", "deleted"
  source          String   @default("manual") // "manual" or "automated_system"
  changedBy       User?    @relation(fields: [changedById], references: [id], onDelete: SetNull)
  changedById     Int?
  previousValue   Json?    // Previous state (for updates)
  newValue        Json?    // New state (for updates)
  timestamp       DateTime @default(now())

  @@index([attendanceId])
  @@index([changedById])
  @@index([timestamp])
  @@index([source])
}

model OrbatTemplate {
  id                    Int       @id @default(autoincrement())
  name                  String    @unique
  description           String?
  category              String?   // "Combat", "Training", "Transport", "Garrison", etc
  tagsJson              String?   // Comma-separated tags for filtering
  
  // Full ORBAT structure as JSON
  slotsJson             Json      // [{name, orderIndex, subslots: [{name, orderIndex, maxSignups}]}]
  frequencyIds          Int[]     // Array of RadioFrequency IDs
  
  // Optional faction/intel defaults
  bluforCountry         String?
  bluforRelationship    String?
  opforCountry          String?
  opforRelationship     String?
  indepCountry          String?
  indepRelationship     String?
  iedThreat             String?
  civilianRelationship  String?
  rulesOfEngagement     String?
  airspace              String?
  inGameTimezone        String?
  operationDay          String?
  startTime             String?   // Default HH:MM format
  endTime               String?   // Default HH:MM format
  
  // Admin metadata
  createdBy             User      @relation(fields: [createdById], references: [id])
  createdById           Int
  createdAt             DateTime  @default(now())
  updatedAt             DateTime  @updatedAt
  
  usageCount            Int       @default(0)
  isActive              Boolean   @default(true)
}

enum TrainingRequestStatus {
  pending
  approved
  rejected
  completed
}

model Training {
  id                Int                @id @default(autoincrement())
  name              String
  description       String?
  category          TrainingCategory?  @relation(fields: [categoryId], references: [id], onDelete: SetNull)
  categoryId        Int?               // Foreign key to TrainingCategory
  duration          Int?               // Duration in minutes
  // Rank/training prerequisites
  requiredForNewPeople Boolean         @default(false)
  isActive          Boolean            @default(true)
  createdAt         DateTime           @default(now())
  updatedAt         DateTime           @updatedAt
  userTrainings     UserTraining[]
  trainingRequests  TrainingRequest[]
  // Relations for prerequisites and rank transitions
  rankRequirement   TrainingRankRequirement?
  requiresTrainings TrainingTrainingRequirement[] @relation("RequiresTutorial")
  requiredByTrainings TrainingTrainingRequirement[] @relation("RequiredBy")
  rankTransitions   RankTransitionRequirement[] @relation("RankTransitionRequirement")
}

model TrainingCategory {
  id        Int         @id @default(autoincrement())
  name      String      @unique
  orderIndex Int        @default(0)
  createdAt DateTime    @default(now())
  updatedAt DateTime    @updatedAt
  trainings Training[]
}

model UserTraining {
  id              Int       @id @default(autoincrement())
  user            User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  userId          Int
  training        Training  @relation(fields: [trainingId], references: [id], onDelete: Cascade)
  trainingId      Int
  completedAt     DateTime  @default(now())
  needsRetraining Boolean   @default(false) // Flag to indicate retraining is needed
  isHidden        Boolean   @default(false) // Admin can hide this training from user view
  notes           String?   // Admin notes about completion
  assignedAt      DateTime  @default(now())

  @@unique([userId, trainingId])
  @@index([userId])
  @@index([trainingId])
}

model TrainingRequest {
  id              Int                   @id @default(autoincrement())
  user            User                  @relation(fields: [userId], references: [id], onDelete: Cascade)
  userId          Int
  training        Training              @relation(fields: [trainingId], references: [id], onDelete: Cascade)
  trainingId      Int
  status          TrainingRequestStatus @default(pending)
  requestMessage  String?               // User's message/reason for requesting
  adminResponse   String?               // Admin's response or notes
  handledByAdmin  User?                 @relation("TrainingRequestHandledBy", fields: [handledByAdminId], references: [id])
  handledByAdminId Int?
  requestedAt     DateTime              @default(now())
  updatedAt       DateTime              @updatedAt

  @@index([userId])
  @@index([trainingId])
  @@index([status])
  @@index([handledByAdminId])
}

// Legacy data tables for import process - stays as legacy only
model LegacyAttendanceData {
  id              Int              @id @default(autoincrement())
  legacyName      String           // Discord username + rank from old system (e.g., "Maj Stas")
  legacyUserId    String?          // User ID from legacy CSV (e.g., "12345") - used to match records across imports
  legacyStatus    String           // Original status code: P, A, NA, LOA, NO, EO
  legacyNotes     String?          // Notes from original data
  legacyEventDate DateTime?        // Event date from legacy system (e.g., "9-Jan-2025")
  
  // Mapping to actual system (user only, no signup/orbat)
  mappedUser      User?            @relation(fields: [mappedUserId], references: [id], onDelete: SetNull)
  mappedUserId    Int?             // Link to actual user in system after mapping
  
  // Status tracking
  isMapped        Boolean          @default(false)
  
  createdAt       DateTime         @default(now())
  updatedAt       DateTime         @updatedAt

  @@index([isMapped])
  @@index([legacyUserId])
  @@index([mappedUserId])
  @@index([legacyEventDate])
}

// =====================
// Rank System - Phase 1
// =====================

model Rank {
  id                              Int       @id @default(autoincrement())
  name                            String    @unique
  abbreviation                    String    @unique
  orderIndex                      Int

  attendanceRequiredSinceLastRank Int?
  autoRankupEnabled               Boolean   @default(false)

  // Relations
  userRanks                       UserRank[]
  trainingRequirementsMin         TrainingRankRequirement[]
  transitionRequirementsTarget    RankTransitionRequirement[]

  createdAt                       DateTime  @default(now())
  updatedAt                       DateTime  @updatedAt
}

model UserRank {
  id                      Int       @id @default(autoincrement())
  user                    User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  userId                  Int       @unique

  currentRank             Rank?     @relation(fields: [currentRankId], references: [id], onDelete: SetNull)
  currentRankId           Int?

  lastRankedUpAt          DateTime  @default(now())
  attendanceSinceLastRank Int       @default(0)

  retired                 Boolean   @default(false)
  interviewDone           Boolean   @default(false)

  createdAt               DateTime  @default(now())
  updatedAt               DateTime  @updatedAt

  @@index([userId])
  @@index([currentRankId])
}

model RankHistory {
  id                           Int       @id @default(autoincrement())
  user                         User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  userId                       Int

  previousRankName             String?
  newRankName                  String

  attendanceTotalAtChange      Int
  attendanceDeltaSinceLastRank Int

  triggeredBy                  String    @db.VarChar(20)
  triggeredByUserId            Int?
  triggeredByDiscordId         String?

  outcome                      String?   @db.VarChar(20)
  declineReason                String?
  note                         String?

  createdAt                    DateTime  @default(now())

  @@index([userId])
  @@index([createdAt])
  @@index([triggeredBy])
}

model RankTransitionRequirement {
  id                Int       @id @default(autoincrement())
  targetRank        Rank      @relation(fields: [targetRankId], references: [id], onDelete: Cascade)
  targetRankId      Int

  requiredTrainings Training[] @relation("RankTransitionRequirement")

  createdAt         DateTime  @default(now())
  updatedAt         DateTime  @updatedAt

  @@unique([targetRankId])
  @@index([targetRankId])
}

model TrainingRankRequirement {
  id              Int       @id @default(autoincrement())
  training        Training  @relation(fields: [trainingId], references: [id], onDelete: Cascade)
  trainingId      Int
  minimumRank     Rank?     @relation(fields: [minimumRankId], references: [id], onDelete: SetNull)
  minimumRankId   Int?
  createdAt       DateTime  @default(now())
  updatedAt       DateTime  @updatedAt

  @@unique([trainingId])
  @@index([trainingId])
  @@index([minimumRankId])
}

model TrainingTrainingRequirement {
  id                   Int       @id @default(autoincrement())
  training             Training  @relation("RequiresTutorial", fields: [trainingId], references: [id], onDelete: Cascade)
  trainingId           Int
  requiredTraining     Training  @relation("RequiredBy", fields: [requiredTrainingId], references: [id], onDelete: Cascade)
  requiredTrainingId   Int
  createdAt            DateTime  @default(now())
  updatedAt            DateTime  @updatedAt

  @@unique([trainingId, requiredTrainingId])
  @@index([trainingId])
  @@index([requiredTrainingId])
}

model PromotionProposal {
  id                           Int       @id @default(autoincrement())
  user                         User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  userId                       Int
  currentRankId                Int
  nextRankId                   Int
  attendanceTotalAtProposal    Int
  attendanceDeltaSinceLastRank Int
  status                       String    @db.VarChar(20)
  createdAt                    DateTime  @default(now())
  updatedAt                    DateTime  @updatedAt

  @@unique([userId, nextRankId])
  @@index([userId])
  @@index([status])
}
